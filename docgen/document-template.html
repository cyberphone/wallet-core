<!DOCTYPE html>
<html lang='en'>
<head>
  <link rel='icon' href='webpkiorg.png' sizes='192x192'>
  <meta name='viewport' content='initial-scale=1.0'>
  <meta charset='UTF-8'>
  <title>Wallet Core</title>
  <link rel='stylesheet' type='text/css' href='style.css'>
</head>
<body>
<h3 style="text-align:center;font-weight:normal;font-size:1.5em">Saturn - Payment Authorization Wallet</h3>
<i>Disclaimer: this is a specification in an early state, subject to change without notice.</i>
${introduction}
This document describes the core components of the Saturn wallet.
Note that Saturn is a <i>payment authorization </i> system for end-users,
not a payment system.  Saturn is heavily influenced by the current
&quot;gold&nbsp;standard&quot; for consumer payments, ${href.emv}.
<p style='padding-bottom:0;margin-bottom:0'>
Compared to EMV, Saturn introduces several enhancements:
</p>
<ul style='padding-top:0;margin-top:0'>
  <li style='padding-top:0.5em'>For privacy reasons user authorizations are <i>encrypted</i>.</li>
  <li>Intended to work with <i>any</i> account based payment system.</li>
  <li>Eliminates specific on-line solutions like 3D Secure.</li>
  <li>Receipt option.</li>
  <li>Account balance option.</li>
  <li>Built-in support for authorization of non-direct payments.</li>
</ul>
<p>
Saturn builds on the idea that different payment networks should not
need unique user authorizations solutions; only identifiers
related to accounts and payment networks need to be adapted.
This data is provided in the associated virtual payment cards (payment credentials),
potentially making the wallet software <i>universal</i>.
</p>
The sequence diagram below outlines the Saturn protocol: 
<div class='webpkifloat'><img src='sequence-diagram.png' class='webpkibox' style='width:50em' title='Sequence Diagram'></div>
${detailed-operation}
To guide the reader, operation is described based on an example which
in turn provides links to the formal definitions.
<p>
The Saturn protocol is based on CBOR [${href.rfc8949}] which is a <i>binary</i> interchange format.
However, for documentation purposes, messages are shown in <i>diagnostic notation</i>.
</p>
${wallet-initiation}
The payment proccess is initiated when the Payer hits a &quot;Pay&quot;
button on the Web or scans a QR-code, returning a wallet activation URL.
The wallet should then use the received URL for performing an HTTP&nbsp;GET
(step #1 in the sequence diagram) to the Payee service.
This operation should return an ${href.authorization-request} object
(step #2 in the sequence diagram) like the following:
${authz-req.txt}
${wallet-request-ui}
After receival of the ${href.authorization-request},
the wallet should display a UI like the following:
<div class='webpkifloat'><img src='wallet-ui.svg' style='padding:0;width:25em' class='webpkibox'  title='Wallet UI'></div>
If the wallet contains multiple 
${href.payment-credentials}
matching the Payee
request, the Payer needs to select (step #3 in the sequence diagram) a suitable
credential, unless the default (or last used) is deamed suitable.
${payer-authorization}
Assuming that the Payer accepts and subsequently authorizes 
the request (step #4 in the sequence diagram),
the wallet should perform an HTTP&nbsp;POST (step #5 in the sequence diagram)
to the Payee service containing an
${href.authorization-response}
object like the following: 
${authz-res.txt}
Note that the POST <b>must</b> be directed to the same URL as
used by the GET in ${href.wallet-initiation}.
${wallet-termination}
After successful (or failed) authorization, the 
${href.authorization-response}
should return a message (step #6 in the sequence diagram).
This message depends on how the payment process was initiated,
and is yet to be specified.
${message-reference}
This section contains a reference to the components underpinning Saturn messages.
The components are based on CBOR <code>map</code> objects.
${authorization-request}
${authorization-response}
${pass-through-data}
${payment-request}
${service-provider}
${signed-authorization}
${payment-credentials}
A fundamental part of the wallet is a local database holding
enrolled payment credentials.
Note that although credential data types are expressed as CBOR,
other representations may be used.
The only requirement is that credential data types can be securely
mapped back and forth to CBOR.
<p style='margin-bottom:0.5em;padding-bottom:0'>
Each entry in the database contains a payment credential according
to the following definition:
</p>
${payment-credential}
${authorization-processing}
This section describes how
${href.authorization-response} messages
should be processed, using the ${href.payer-authorization} sample and
associated ${href.test-vectors} as model data.
${decryption}
Firstly the ${href.authorization-response}
object needs to be <i>decrypted</i> using a private key associated with the 
supplied ${href.cef} <kbd>publicKey</kbd> or <kbd>keyId</kbd> attribute.
In the sample, a <kbd>publicKey</kbd> attribute was used.
The decryption process should return two CBOR objects:
the ${href.pass-through-data}
object which is supplied in clear:
${pass-through-data.txt}
and another object which after decryption should read like the following:
${restored.txt}
${signature-validation}
Now combine the objects retrieved during the decryption phase
by copying the first object (${href.pass-through-data})
to a label <code>1</code> of the second object.
Note that the length of the resulting <code>map</code> object
<b>must</b> be updated to reflect the addition of an item.
This operation effectively <i>recreates</i> the ${href.signed-authorization} object:
${signed-authz.txt}
Since this object contains a ${href.csf} <kbd>publicKey</kbd>
attribute, it can be validated using &quot;as&nbsp;is&quot;.
<p>
Note that the <i>authenticity</i> of received public keys <b>must</b>
be verified <i>before</i> authorization objects are acted upon!
</p>
<p>
Unsurprisingly, authorization objects <b>must</b> also
be checked for alignment with the specification.
Missing, additional, or malformed elements <b>must</b> be rejected.
</p>
${test-vectors}
Equipped with an appropriate diagnostic notation parser like
<a href='https://cyberphone.github.io/CBOR.js/doc/playground.html'>
https://cyberphone.github.io/CBOR.js/doc/playground.html
</a> and ${href.cef}/${href.csf} support, the ${href.payer-authorization} sample
should be possible to decrypt and validate, using the following sample keys.
<div style='margin-top:0.8em'>Authorization key in JWK format:</div>
${authorization-key.jwk}
<div style='margin-top:0.8em'>Authorization key in COSE format:</div>
${authorization-key.txt}
<div style='margin-top:0.8em'>Encryption key in JWK format:</div>
${encryption-key.jwk}
<div style='margin-top:0.8em'>Encryption key in COSE format:</div>
${encryption-key.txt}
${version}
  API version: 1.0.0<br>
  Document version: 2024-09-07
</body>
</html>